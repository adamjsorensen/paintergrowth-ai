
import { BoilerplateText, MergedContent } from "@/types/boilerplate";

/**
 * Replaces placeholders in a boilerplate text with provided values
 * @param content The text content containing placeholders
 * @param values Object containing placeholder values
 * @param defaults Object containing default values for placeholders
 * @returns MergedContent containing final text and placeholder resolution info
 */
export const replacePlaceholders = (
  content: string,
  values: Record<string, any>,
  defaults: Record<string, string> = {}
): MergedContent => {
  const resolvedPlaceholders = new Map<string, string>();
  const unresolvedPlaceholders: string[] = [];
  
  // Regular expression to match {{placeholder}} pattern
  const placeholderRegex = /{{([^{}]+)}}/g;
  
  // Replace placeholders with values
  const processedContent = content.replace(placeholderRegex, (match, placeholder) => {
    // Check if the value exists in provided values
    if (values[placeholder] !== undefined && values[placeholder] !== null) {
      resolvedPlaceholders.set(placeholder, String(values[placeholder]));
      return String(values[placeholder]);
    }
    
    // Check if the value exists in defaults
    if (defaults[placeholder]) {
      resolvedPlaceholders.set(placeholder, defaults[placeholder]);
      return defaults[placeholder];
    }
    
    // Placeholder is unresolved
    unresolvedPlaceholders.push(placeholder);
    return match; // Keep the original placeholder
  });
  
  return {
    content: processedContent,
    resolvedPlaceholders,
    unresolvedPlaceholders
  };
};

/**
 * Merges LLM-generated content with boilerplate texts
 * @param generatedContent The content generated by LLM
 * @param boilerplateTexts Array of boilerplate texts to append
 * @param values Values to replace placeholders with
 * @param defaultPlaceholders Default values for placeholders
 * @param locale Desired locale for boilerplate texts
 * @returns Complete merged content
 */
export const mergeWithBoilerplate = (
  generatedContent: string,
  boilerplateTexts: BoilerplateText[],
  values: Record<string, any>,
  defaultPlaceholders: Record<string, string> = {},
  locale: string = 'en-US'
): string => {
  // Start with the LLM-generated content
  let fullContent = generatedContent;
  
  // Process each boilerplate text
  boilerplateTexts.forEach(boilerplate => {
    // Only use boilerplate texts matching the requested locale
    if (boilerplate.locale !== locale) {
      return;
    }
    
    const { content: processedBoilerplate } = replacePlaceholders(
      boilerplate.content,
      values,
      defaultPlaceholders
    );
    
    // Add section heading based on boilerplate type
    let sectionTitle = '';
    switch (boilerplate.type) {
      case 'terms_conditions':
        sectionTitle = '## Terms and Conditions';
        break;
      case 'warranty':
        sectionTitle = '## Warranty';
        break;
      case 'invoice_note':
        sectionTitle = '## Invoice Notes';
        break;
      default:
        sectionTitle = `## ${boilerplate.type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
    }
    
    // Append boilerplate content with proper spacing and heading
    fullContent += `\n\n${sectionTitle}\n\n${processedBoilerplate}`;
  });
  
  return fullContent;
};

/**
 * Extracts placeholder names from boilerplate text
 * @param content The text content to analyze
 * @returns Array of placeholder names
 */
export const extractPlaceholders = (content: string): string[] => {
  const placeholderRegex = /{{([^{}]+)}}/g;
  const placeholders: string[] = [];
  let match;
  
  while ((match = placeholderRegex.exec(content)) !== null) {
    placeholders.push(match[1]);
  }
  
  return [...new Set(placeholders)]; // Return unique placeholders
};
