import { BoilerplateText, MergedContent } from "@/types/boilerplate";

/**
 * Replaces placeholders in a boilerplate text with provided values
 * @param content The text content containing placeholders
 * @param values Object containing placeholder values
 * @param defaults Object containing default values for placeholders
 * @returns MergedContent containing final text and placeholder resolution info
 */
export const replacePlaceholders = (
  content: string,
  values: Record<string, any>,
  defaults: Record<string, string> = {}
): MergedContent => {
  const resolvedPlaceholders = new Map<string, string>();
  const unresolvedPlaceholders: string[] = [];
  
  // Regular expression to match {{placeholder}} pattern
  const placeholderRegex = /{{([^{}]+)}}/g;
  
  // Replace placeholders with values
  const processedContent = content.replace(placeholderRegex, (match, placeholder) => {
    try {
      // Check if the value exists in provided values
      if (values[placeholder] !== undefined && values[placeholder] !== null) {
        resolvedPlaceholders.set(placeholder, String(values[placeholder]));
        return String(values[placeholder]);
      }
      
      // Check if the value exists in defaults
      if (defaults[placeholder]) {
        resolvedPlaceholders.set(placeholder, defaults[placeholder]);
        return defaults[placeholder];
      }
      
      // Placeholder is unresolved
      unresolvedPlaceholders.push(placeholder);
      return match; // Keep the original placeholder
    } catch (e) {
      // Log error and keep the placeholder in content
      console.error(`Error replacing placeholder "${placeholder}":`, e);
      unresolvedPlaceholders.push(placeholder);
      return match;
    }
  });
  
  return {
    content: processedContent,
    resolvedPlaceholders,
    unresolvedPlaceholders
  };
};

/**
 * Merges LLM-generated content with boilerplate texts (typed)
 * @param generatedContent The content generated by LLM
 * @param boilerplateTexts Array of boilerplate texts to append (type-safe)
 * @param values Values to replace placeholders with
 * @param defaultPlaceholders Default values for placeholders
 * @param locale Desired locale for boilerplate texts
 * @returns Complete merged content
 */
export const mergeWithBoilerplate = (
  generatedContent: string,
  boilerplateTexts: BoilerplateText[],
  values: Record<string, any>,
  defaultPlaceholders: Record<string, string> = {},
  locale: string = 'en-US'
): string => {
  // Start with the LLM-generated content
  let fullContent = generatedContent;
  
  // Process each boilerplate text
  boilerplateTexts.forEach((boilerplate: BoilerplateText) => {
    // Only use boilerplate texts matching the requested locale
    if (boilerplate.locale !== locale) {
      return;
    }
    let processedBoilerplate: string;
    try {
      const { content: replacedContent } = replacePlaceholders(
        boilerplate.content,
        values,
        defaultPlaceholders
      );
      processedBoilerplate = replacedContent;
    } catch (e) {
      // Log an error if placeholder replacement fails
      console.error(`Failed to replace placeholders for boilerplate "${boilerplate.type}" (${boilerplate.locale})`, e);
      processedBoilerplate = boilerplate.content; // fallback to raw content
    }
    
    // Add section heading based on boilerplate type
    let sectionTitle = '';
    switch (boilerplate.type) {
      case 'terms_conditions':
        sectionTitle = '## Terms and Conditions';
        break;
      case 'warranty':
        sectionTitle = '## Warranty';
        break;
      case 'invoice_note':
        sectionTitle = '## Invoice Notes';
        break;
      default:
        sectionTitle = `## ${boilerplate.type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
    }
    
    // Append boilerplate content with proper spacing and heading
    fullContent += `\n\n${sectionTitle}\n\n${processedBoilerplate}`;
  });
  
  return fullContent;
};

/**
 * Type-safe version of merging generated content with boilerplate texts.
 * Returns merged content or logs errors as needed.
 */
export function mergeBoilerplateContent(
  generatedContent: string,
  boilerplateTexts: BoilerplateText[],
  values: Record<string, any>,
  defaultPlaceholders: Record<string, string> = {}
): string {
  let fullContent = generatedContent;
  for (const boilerplate of boilerplateTexts) {
    let processedContent: string;
    try {
      const { content: replacedContent } = replacePlaceholders(
        boilerplate.content,
        values,
        defaultPlaceholders
      );
      processedContent = replacedContent;
    } catch (e) {
      // Log details about the boilerplate and error
      console.error(
        `Error replacing placeholders in boilerplate [${boilerplate.type} - ${boilerplate.locale}]:`,
        e
      );
      processedContent = boilerplate.content; // fallback to raw content
    }

    let sectionTitle: string;
    switch (boilerplate.type) {
      case 'terms_conditions':
        sectionTitle = '## Terms and Conditions';
        break;
      case 'warranty':
        sectionTitle = '## Warranty';
        break;
      case 'invoice_note':
        sectionTitle = '## Invoice Notes';
        break;
      default:
        sectionTitle = `## ${boilerplate.type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
    }

    fullContent += `\n\n${sectionTitle}\n\n${processedContent}`;
  }
  return fullContent;
}

/**
 * Extracts placeholder names from boilerplate text
 * @param content The text content to analyze
 * @returns Array of placeholder names
 */
export const extractPlaceholders = (content: string): string[] => {
  const placeholderRegex = /{{([^{}]+)}}/g;
  const placeholders: string[] = [];
  let match;
  
  while ((match = placeholderRegex.exec(content)) !== null) {
    placeholders.push(match[1]);
  }
  
  return [...new Set(placeholders)]; // Return unique placeholders
};
