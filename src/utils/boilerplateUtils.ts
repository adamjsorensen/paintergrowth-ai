
import { BoilerplateText, MergedContent } from "@/types/boilerplate";
import { CompanyProfile } from "@/types/supabase";

/**
 * Creates a mapping of placeholders to effective default values based on
 * the company profile data and placeholder mapping
 *
 * @param companyProfileData The user's company profile data
 * @param placeholderMapping Mapping from placeholders to company profile field keys
 * @returns Record mapping placeholders to their resolved default values
 */
export const createEffectiveDefaults = (
  companyProfileData: CompanyProfile | null,
  placeholderMapping: Record<string, string>
): Record<string, string> => {
  const effectiveDefaults: Record<string, string> = {};
  
  if (!companyProfileData) return effectiveDefaults;
  
  // For each placeholder mapping, look up the corresponding value in the company profile
  Object.entries(placeholderMapping).forEach(([placeholder, profileFieldKey]) => {
    // Get the value from the company profile using the field key
    // Using type assertion to access properties dynamically
    const profileValue = companyProfileData[profileFieldKey as keyof CompanyProfile];
    
    // Only add non-null, non-undefined values
    if (profileValue !== null && profileValue !== undefined) {
      // Handle arrays (like brand_keywords) by joining them
      if (Array.isArray(profileValue)) {
        effectiveDefaults[placeholder] = profileValue.join(', ');
      } else {
        effectiveDefaults[placeholder] = String(profileValue);
      }
    }
  });
  
  return effectiveDefaults;
};

/**
 * Replaces placeholders in a boilerplate text with provided values
 * @param content The text content containing placeholders
 * @param values Object containing placeholder values
 * @param defaults Object containing default values for placeholders
 * @returns MergedContent containing final text and placeholder resolution info
 */
export const replacePlaceholders = (
  content: string,
  values: Record<string, any>,
  defaults: Record<string, string> = {}
): MergedContent => {
  const resolvedPlaceholders = new Map<string, string>();
  const unresolvedPlaceholders: string[] = [];
  
  // Regular expression to match {{placeholder}} pattern
  const placeholderRegex = /{{([^{}]+)}}/g;
  
  // Replace placeholders with values
  const processedContent = content.replace(placeholderRegex, (match, placeholder) => {
    try {
      // Check if the value exists in provided values
      if (values[placeholder] !== undefined && values[placeholder] !== null) {
        resolvedPlaceholders.set(placeholder, String(values[placeholder]));
        return String(values[placeholder]);
      }
      
      // Check if the value exists in defaults
      if (defaults[placeholder]) {
        resolvedPlaceholders.set(placeholder, defaults[placeholder]);
        return defaults[placeholder];
      }
      
      // Placeholder is unresolved
      unresolvedPlaceholders.push(placeholder);
      return match; // Keep the original placeholder
    } catch (e) {
      // Log error and keep the placeholder in content
      console.error(`Error replacing placeholder "${placeholder}":`, e);
      unresolvedPlaceholders.push(placeholder);
      return match;
    }
  });
  
  return {
    content: processedContent,
    resolvedPlaceholders,
    unresolvedPlaceholders
  };
};

/**
 * Merges LLM-generated content with boilerplate texts (typed)
 * @param generatedContent The content generated by LLM
 * @param boilerplateTexts Array of boilerplate texts to append (type-safe)
 * @param values Values to replace placeholders with
 * @param defaultPlaceholders Default values for placeholders
 * @param locale Desired locale for boilerplate texts
 * @returns Complete merged content
 */
export const mergeWithBoilerplate = (
  generatedContent: string,
  boilerplateTexts: BoilerplateText[],
  values: Record<string, any>,
  placeholderMapping: Record<string, string> = {},
  companyProfileData: CompanyProfile | null = null,
  locale: string = 'en-US'
): string => {
  // Create effective defaults from company profile data and placeholder mapping
  const effectiveDefaults = createEffectiveDefaults(companyProfileData, placeholderMapping);
  
  // Start with the LLM-generated content
  let fullContent = generatedContent;
  
  // Process each boilerplate text
  boilerplateTexts.forEach((boilerplate: BoilerplateText) => {
    // Only use boilerplate texts matching the requested locale
    if (boilerplate.locale !== locale) {
      return;
    }
    let processedBoilerplate: string;
    try {
      const { content: replacedContent } = replacePlaceholders(
        boilerplate.content,
        values,
        effectiveDefaults
      );
      processedBoilerplate = replacedContent;
    } catch (e) {
      // Log an error if placeholder replacement fails
      console.error(`Failed to replace placeholders for boilerplate "${boilerplate.type}" (${boilerplate.locale})`, e);
      processedBoilerplate = boilerplate.content; // fallback to raw content
    }
    
    // Add section heading based on boilerplate type
    let sectionTitle = '';
    switch (boilerplate.type) {
      case 'terms_conditions':
        sectionTitle = '## Terms and Conditions';
        break;
      case 'warranty':
        sectionTitle = '## Warranty';
        break;
      case 'invoice_note':
        sectionTitle = '## Invoice Notes';
        break;
      default:
        // Type cast to ensure TypeScript knows we have a string
        const boilerplateTypeAsString = String(boilerplate.type);
        sectionTitle = `## ${boilerplateTypeAsString.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
    }
    
    // Append boilerplate content with proper spacing and heading
    fullContent += `\n\n${sectionTitle}\n\n${processedBoilerplate}`;
  });
  
  return fullContent;
};

/**
 * Type-safe version of merging generated content with boilerplate texts.
 * Returns merged content or logs errors as needed.
 */
export function mergeBoilerplateContent(
  generatedContent: string,
  boilerplateTexts: BoilerplateText[],
  values: Record<string, any>,
  placeholderMapping: Record<string, string> = {},
  companyProfileData: CompanyProfile | null = null
): string {
  // Create effective defaults from company profile data and placeholder mapping
  const effectiveDefaults = createEffectiveDefaults(companyProfileData, placeholderMapping);
  
  let fullContent = generatedContent;
  for (const boilerplate of boilerplateTexts) {
    let processedContent: string;
    try {
      const { content: replacedContent } = replacePlaceholders(
        boilerplate.content,
        values,
        effectiveDefaults
      );
      processedContent = replacedContent;
    } catch (e) {
      // Log details about the boilerplate and error
      console.error(
        `Error replacing placeholders in boilerplate [${boilerplate.type} - ${boilerplate.locale}]:`,
        e
      );
      processedContent = boilerplate.content; // fallback to raw content
    }

    let sectionTitle: string;
    switch (boilerplate.type) {
      case 'terms_conditions':
        sectionTitle = '## Terms and Conditions';
        break;
      case 'warranty':
        sectionTitle = '## Warranty';
        break;
      case 'invoice_note':
        sectionTitle = '## Invoice Notes';
        break;
      default:
        // Type cast to ensure TypeScript knows we have a string
        const boilerplateTypeAsString = String(boilerplate.type);
        sectionTitle = `## ${boilerplateTypeAsString.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
    }

    fullContent += `\n\n${sectionTitle}\n\n${processedContent}`;
  }
  return fullContent;
}

/**
 * Extracts placeholder names from boilerplate text
 * @param content The text content to analyze
 * @returns Array of placeholder names
 */
export const extractPlaceholders = (content: string): string[] => {
  const placeholderRegex = /{{([^{}]+)}}/g;
  const placeholders: string[] = [];
  let match;
  
  while ((match = placeholderRegex.exec(content)) !== null) {
    placeholders.push(match[1]);
  }
  
  return [...new Set(placeholders)]; // Return unique placeholders
};